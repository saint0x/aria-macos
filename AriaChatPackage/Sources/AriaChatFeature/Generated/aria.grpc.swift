//
// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the protocol buffer compiler.
// Source: aria.proto
//
import GRPC
import NIO
import NIOConcurrencyHelpers
import SwiftProtobuf


/// Service for managing and interacting with long-running asynchronous tasks.
///
/// Usage: instantiate `Aria_TaskServiceClient`, then call methods of this protocol to make API calls.
public protocol Aria_TaskServiceClientProtocol: GRPCClient {
  var serviceName: String { get }
  var interceptors: Aria_TaskServiceClientInterceptorFactoryProtocol? { get }

  func launchTask(
    _ request: Aria_LaunchTaskRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Aria_LaunchTaskRequest, Aria_LaunchTaskResponse>

  func getTask(
    _ request: Aria_GetTaskRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Aria_GetTaskRequest, Aria_Task>

  func listTasks(
    _ request: Aria_ListTasksRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Aria_ListTasksRequest, Aria_ListTasksResponse>

  func streamTaskOutput(
    _ request: Aria_StreamTaskOutputRequest,
    callOptions: CallOptions?,
    handler: @escaping (Aria_TaskOutput) -> Void
  ) -> ServerStreamingCall<Aria_StreamTaskOutputRequest, Aria_TaskOutput>

  func cancelTask(
    _ request: Aria_CancelTaskRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Aria_CancelTaskRequest, Aria_CancelTaskResponse>
}

extension Aria_TaskServiceClientProtocol {
  public var serviceName: String {
    return "aria.TaskService"
  }

  /// Launches a new asynchronous task.
  ///
  /// - Parameters:
  ///   - request: Request to send to LaunchTask.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func launchTask(
    _ request: Aria_LaunchTaskRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Aria_LaunchTaskRequest, Aria_LaunchTaskResponse> {
    return self.makeUnaryCall(
      path: Aria_TaskServiceClientMetadata.Methods.launchTask.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeLaunchTaskInterceptors() ?? []
    )
  }

  /// Retrieves the current status and details of a task.
  ///
  /// - Parameters:
  ///   - request: Request to send to GetTask.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func getTask(
    _ request: Aria_GetTaskRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Aria_GetTaskRequest, Aria_Task> {
    return self.makeUnaryCall(
      path: Aria_TaskServiceClientMetadata.Methods.getTask.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeGetTaskInterceptors() ?? []
    )
  }

  /// Lists tasks, with support for filtering and pagination.
  ///
  /// - Parameters:
  ///   - request: Request to send to ListTasks.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func listTasks(
    _ request: Aria_ListTasksRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Aria_ListTasksRequest, Aria_ListTasksResponse> {
    return self.makeUnaryCall(
      path: Aria_TaskServiceClientMetadata.Methods.listTasks.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeListTasksInterceptors() ?? []
    )
  }

  /// Streams the output (stdout/stderr) and progress of a running task.
  ///
  /// - Parameters:
  ///   - request: Request to send to StreamTaskOutput.
  ///   - callOptions: Call options.
  ///   - handler: A closure called when each response is received from the server.
  /// - Returns: A `ServerStreamingCall` with futures for the metadata and status.
  public func streamTaskOutput(
    _ request: Aria_StreamTaskOutputRequest,
    callOptions: CallOptions? = nil,
    handler: @escaping (Aria_TaskOutput) -> Void
  ) -> ServerStreamingCall<Aria_StreamTaskOutputRequest, Aria_TaskOutput> {
    return self.makeServerStreamingCall(
      path: Aria_TaskServiceClientMetadata.Methods.streamTaskOutput.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeStreamTaskOutputInterceptors() ?? [],
      handler: handler
    )
  }

  /// Cancels a pending or running task.
  ///
  /// - Parameters:
  ///   - request: Request to send to CancelTask.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func cancelTask(
    _ request: Aria_CancelTaskRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Aria_CancelTaskRequest, Aria_CancelTaskResponse> {
    return self.makeUnaryCall(
      path: Aria_TaskServiceClientMetadata.Methods.cancelTask.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeCancelTaskInterceptors() ?? []
    )
  }
}

@available(*, deprecated)
extension Aria_TaskServiceClient: @unchecked Sendable {}

@available(*, deprecated, renamed: "Aria_TaskServiceNIOClient")
public final class Aria_TaskServiceClient: Aria_TaskServiceClientProtocol {
  private let lock = Lock()
  private var _defaultCallOptions: CallOptions
  private var _interceptors: Aria_TaskServiceClientInterceptorFactoryProtocol?
  public let channel: GRPCChannel
  public var defaultCallOptions: CallOptions {
    get { self.lock.withLock { return self._defaultCallOptions } }
    set { self.lock.withLockVoid { self._defaultCallOptions = newValue } }
  }
  public var interceptors: Aria_TaskServiceClientInterceptorFactoryProtocol? {
    get { self.lock.withLock { return self._interceptors } }
    set { self.lock.withLockVoid { self._interceptors = newValue } }
  }

  /// Creates a client for the aria.TaskService service.
  ///
  /// - Parameters:
  ///   - channel: `GRPCChannel` to the service host.
  ///   - defaultCallOptions: Options to use for each service call if the user doesn't provide them.
  ///   - interceptors: A factory providing interceptors for each RPC.
  public init(
    channel: GRPCChannel,
    defaultCallOptions: CallOptions = CallOptions(),
    interceptors: Aria_TaskServiceClientInterceptorFactoryProtocol? = nil
  ) {
    self.channel = channel
    self._defaultCallOptions = defaultCallOptions
    self._interceptors = interceptors
  }
}

public struct Aria_TaskServiceNIOClient: Aria_TaskServiceClientProtocol {
  public var channel: GRPCChannel
  public var defaultCallOptions: CallOptions
  public var interceptors: Aria_TaskServiceClientInterceptorFactoryProtocol?

  /// Creates a client for the aria.TaskService service.
  ///
  /// - Parameters:
  ///   - channel: `GRPCChannel` to the service host.
  ///   - defaultCallOptions: Options to use for each service call if the user doesn't provide them.
  ///   - interceptors: A factory providing interceptors for each RPC.
  public init(
    channel: GRPCChannel,
    defaultCallOptions: CallOptions = CallOptions(),
    interceptors: Aria_TaskServiceClientInterceptorFactoryProtocol? = nil
  ) {
    self.channel = channel
    self.defaultCallOptions = defaultCallOptions
    self.interceptors = interceptors
  }
}

/// Service for managing and interacting with long-running asynchronous tasks.
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
public protocol Aria_TaskServiceAsyncClientProtocol: GRPCClient {
  static var serviceDescriptor: GRPCServiceDescriptor { get }
  var interceptors: Aria_TaskServiceClientInterceptorFactoryProtocol? { get }

  func makeLaunchTaskCall(
    _ request: Aria_LaunchTaskRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Aria_LaunchTaskRequest, Aria_LaunchTaskResponse>

  func makeGetTaskCall(
    _ request: Aria_GetTaskRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Aria_GetTaskRequest, Aria_Task>

  func makeListTasksCall(
    _ request: Aria_ListTasksRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Aria_ListTasksRequest, Aria_ListTasksResponse>

  func makeStreamTaskOutputCall(
    _ request: Aria_StreamTaskOutputRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncServerStreamingCall<Aria_StreamTaskOutputRequest, Aria_TaskOutput>

  func makeCancelTaskCall(
    _ request: Aria_CancelTaskRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Aria_CancelTaskRequest, Aria_CancelTaskResponse>
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension Aria_TaskServiceAsyncClientProtocol {
  public static var serviceDescriptor: GRPCServiceDescriptor {
    return Aria_TaskServiceClientMetadata.serviceDescriptor
  }

  public var interceptors: Aria_TaskServiceClientInterceptorFactoryProtocol? {
    return nil
  }

  public func makeLaunchTaskCall(
    _ request: Aria_LaunchTaskRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Aria_LaunchTaskRequest, Aria_LaunchTaskResponse> {
    return self.makeAsyncUnaryCall(
      path: Aria_TaskServiceClientMetadata.Methods.launchTask.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeLaunchTaskInterceptors() ?? []
    )
  }

  public func makeGetTaskCall(
    _ request: Aria_GetTaskRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Aria_GetTaskRequest, Aria_Task> {
    return self.makeAsyncUnaryCall(
      path: Aria_TaskServiceClientMetadata.Methods.getTask.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeGetTaskInterceptors() ?? []
    )
  }

  public func makeListTasksCall(
    _ request: Aria_ListTasksRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Aria_ListTasksRequest, Aria_ListTasksResponse> {
    return self.makeAsyncUnaryCall(
      path: Aria_TaskServiceClientMetadata.Methods.listTasks.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeListTasksInterceptors() ?? []
    )
  }

  public func makeStreamTaskOutputCall(
    _ request: Aria_StreamTaskOutputRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncServerStreamingCall<Aria_StreamTaskOutputRequest, Aria_TaskOutput> {
    return self.makeAsyncServerStreamingCall(
      path: Aria_TaskServiceClientMetadata.Methods.streamTaskOutput.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeStreamTaskOutputInterceptors() ?? []
    )
  }

  public func makeCancelTaskCall(
    _ request: Aria_CancelTaskRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Aria_CancelTaskRequest, Aria_CancelTaskResponse> {
    return self.makeAsyncUnaryCall(
      path: Aria_TaskServiceClientMetadata.Methods.cancelTask.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeCancelTaskInterceptors() ?? []
    )
  }
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension Aria_TaskServiceAsyncClientProtocol {
  public func launchTask(
    _ request: Aria_LaunchTaskRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Aria_LaunchTaskResponse {
    return try await self.performAsyncUnaryCall(
      path: Aria_TaskServiceClientMetadata.Methods.launchTask.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeLaunchTaskInterceptors() ?? []
    )
  }

  public func getTask(
    _ request: Aria_GetTaskRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Aria_Task {
    return try await self.performAsyncUnaryCall(
      path: Aria_TaskServiceClientMetadata.Methods.getTask.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeGetTaskInterceptors() ?? []
    )
  }

  public func listTasks(
    _ request: Aria_ListTasksRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Aria_ListTasksResponse {
    return try await self.performAsyncUnaryCall(
      path: Aria_TaskServiceClientMetadata.Methods.listTasks.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeListTasksInterceptors() ?? []
    )
  }

  public func streamTaskOutput(
    _ request: Aria_StreamTaskOutputRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncResponseStream<Aria_TaskOutput> {
    return self.performAsyncServerStreamingCall(
      path: Aria_TaskServiceClientMetadata.Methods.streamTaskOutput.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeStreamTaskOutputInterceptors() ?? []
    )
  }

  public func cancelTask(
    _ request: Aria_CancelTaskRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Aria_CancelTaskResponse {
    return try await self.performAsyncUnaryCall(
      path: Aria_TaskServiceClientMetadata.Methods.cancelTask.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeCancelTaskInterceptors() ?? []
    )
  }
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
public struct Aria_TaskServiceAsyncClient: Aria_TaskServiceAsyncClientProtocol {
  public var channel: GRPCChannel
  public var defaultCallOptions: CallOptions
  public var interceptors: Aria_TaskServiceClientInterceptorFactoryProtocol?

  public init(
    channel: GRPCChannel,
    defaultCallOptions: CallOptions = CallOptions(),
    interceptors: Aria_TaskServiceClientInterceptorFactoryProtocol? = nil
  ) {
    self.channel = channel
    self.defaultCallOptions = defaultCallOptions
    self.interceptors = interceptors
  }
}

public protocol Aria_TaskServiceClientInterceptorFactoryProtocol: Sendable {

  /// - Returns: Interceptors to use when invoking 'launchTask'.
  func makeLaunchTaskInterceptors() -> [ClientInterceptor<Aria_LaunchTaskRequest, Aria_LaunchTaskResponse>]

  /// - Returns: Interceptors to use when invoking 'getTask'.
  func makeGetTaskInterceptors() -> [ClientInterceptor<Aria_GetTaskRequest, Aria_Task>]

  /// - Returns: Interceptors to use when invoking 'listTasks'.
  func makeListTasksInterceptors() -> [ClientInterceptor<Aria_ListTasksRequest, Aria_ListTasksResponse>]

  /// - Returns: Interceptors to use when invoking 'streamTaskOutput'.
  func makeStreamTaskOutputInterceptors() -> [ClientInterceptor<Aria_StreamTaskOutputRequest, Aria_TaskOutput>]

  /// - Returns: Interceptors to use when invoking 'cancelTask'.
  func makeCancelTaskInterceptors() -> [ClientInterceptor<Aria_CancelTaskRequest, Aria_CancelTaskResponse>]
}

public enum Aria_TaskServiceClientMetadata {
  public static let serviceDescriptor = GRPCServiceDescriptor(
    name: "TaskService",
    fullName: "aria.TaskService",
    methods: [
      Aria_TaskServiceClientMetadata.Methods.launchTask,
      Aria_TaskServiceClientMetadata.Methods.getTask,
      Aria_TaskServiceClientMetadata.Methods.listTasks,
      Aria_TaskServiceClientMetadata.Methods.streamTaskOutput,
      Aria_TaskServiceClientMetadata.Methods.cancelTask,
    ]
  )

  public enum Methods {
    public static let launchTask = GRPCMethodDescriptor(
      name: "LaunchTask",
      path: "/aria.TaskService/LaunchTask",
      type: GRPCCallType.unary
    )

    public static let getTask = GRPCMethodDescriptor(
      name: "GetTask",
      path: "/aria.TaskService/GetTask",
      type: GRPCCallType.unary
    )

    public static let listTasks = GRPCMethodDescriptor(
      name: "ListTasks",
      path: "/aria.TaskService/ListTasks",
      type: GRPCCallType.unary
    )

    public static let streamTaskOutput = GRPCMethodDescriptor(
      name: "StreamTaskOutput",
      path: "/aria.TaskService/StreamTaskOutput",
      type: GRPCCallType.serverStreaming
    )

    public static let cancelTask = GRPCMethodDescriptor(
      name: "CancelTask",
      path: "/aria.TaskService/CancelTask",
      type: GRPCCallType.unary
    )
  }
}

/// Service for managing user sessions and conversations.
///
/// Usage: instantiate `Aria_SessionServiceClient`, then call methods of this protocol to make API calls.
public protocol Aria_SessionServiceClientProtocol: GRPCClient {
  var serviceName: String { get }
  var interceptors: Aria_SessionServiceClientInterceptorFactoryProtocol? { get }

  func createSession(
    _ request: Aria_CreateSessionRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Aria_CreateSessionRequest, Aria_Session>

  func getSession(
    _ request: Aria_GetSessionRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Aria_GetSessionRequest, Aria_Session>

  func executeTurn(
    _ request: Aria_ExecuteTurnRequest,
    callOptions: CallOptions?,
    handler: @escaping (Aria_TurnOutput) -> Void
  ) -> ServerStreamingCall<Aria_ExecuteTurnRequest, Aria_TurnOutput>
}

extension Aria_SessionServiceClientProtocol {
  public var serviceName: String {
    return "aria.SessionService"
  }

  /// Creates a new session for a user.
  ///
  /// - Parameters:
  ///   - request: Request to send to CreateSession.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func createSession(
    _ request: Aria_CreateSessionRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Aria_CreateSessionRequest, Aria_Session> {
    return self.makeUnaryCall(
      path: Aria_SessionServiceClientMetadata.Methods.createSession.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeCreateSessionInterceptors() ?? []
    )
  }

  /// Gets details for a specific session.
  ///
  /// - Parameters:
  ///   - request: Request to send to GetSession.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func getSession(
    _ request: Aria_GetSessionRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Aria_GetSessionRequest, Aria_Session> {
    return self.makeUnaryCall(
      path: Aria_SessionServiceClientMetadata.Methods.getSession.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeGetSessionInterceptors() ?? []
    )
  }

  /// Executes a "turn" in a conversation within a session.
  ///
  /// - Parameters:
  ///   - request: Request to send to ExecuteTurn.
  ///   - callOptions: Call options.
  ///   - handler: A closure called when each response is received from the server.
  /// - Returns: A `ServerStreamingCall` with futures for the metadata and status.
  public func executeTurn(
    _ request: Aria_ExecuteTurnRequest,
    callOptions: CallOptions? = nil,
    handler: @escaping (Aria_TurnOutput) -> Void
  ) -> ServerStreamingCall<Aria_ExecuteTurnRequest, Aria_TurnOutput> {
    return self.makeServerStreamingCall(
      path: Aria_SessionServiceClientMetadata.Methods.executeTurn.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeExecuteTurnInterceptors() ?? [],
      handler: handler
    )
  }
}

@available(*, deprecated)
extension Aria_SessionServiceClient: @unchecked Sendable {}

@available(*, deprecated, renamed: "Aria_SessionServiceNIOClient")
public final class Aria_SessionServiceClient: Aria_SessionServiceClientProtocol {
  private let lock = Lock()
  private var _defaultCallOptions: CallOptions
  private var _interceptors: Aria_SessionServiceClientInterceptorFactoryProtocol?
  public let channel: GRPCChannel
  public var defaultCallOptions: CallOptions {
    get { self.lock.withLock { return self._defaultCallOptions } }
    set { self.lock.withLockVoid { self._defaultCallOptions = newValue } }
  }
  public var interceptors: Aria_SessionServiceClientInterceptorFactoryProtocol? {
    get { self.lock.withLock { return self._interceptors } }
    set { self.lock.withLockVoid { self._interceptors = newValue } }
  }

  /// Creates a client for the aria.SessionService service.
  ///
  /// - Parameters:
  ///   - channel: `GRPCChannel` to the service host.
  ///   - defaultCallOptions: Options to use for each service call if the user doesn't provide them.
  ///   - interceptors: A factory providing interceptors for each RPC.
  public init(
    channel: GRPCChannel,
    defaultCallOptions: CallOptions = CallOptions(),
    interceptors: Aria_SessionServiceClientInterceptorFactoryProtocol? = nil
  ) {
    self.channel = channel
    self._defaultCallOptions = defaultCallOptions
    self._interceptors = interceptors
  }
}

public struct Aria_SessionServiceNIOClient: Aria_SessionServiceClientProtocol {
  public var channel: GRPCChannel
  public var defaultCallOptions: CallOptions
  public var interceptors: Aria_SessionServiceClientInterceptorFactoryProtocol?

  /// Creates a client for the aria.SessionService service.
  ///
  /// - Parameters:
  ///   - channel: `GRPCChannel` to the service host.
  ///   - defaultCallOptions: Options to use for each service call if the user doesn't provide them.
  ///   - interceptors: A factory providing interceptors for each RPC.
  public init(
    channel: GRPCChannel,
    defaultCallOptions: CallOptions = CallOptions(),
    interceptors: Aria_SessionServiceClientInterceptorFactoryProtocol? = nil
  ) {
    self.channel = channel
    self.defaultCallOptions = defaultCallOptions
    self.interceptors = interceptors
  }
}

/// Service for managing user sessions and conversations.
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
public protocol Aria_SessionServiceAsyncClientProtocol: GRPCClient {
  static var serviceDescriptor: GRPCServiceDescriptor { get }
  var interceptors: Aria_SessionServiceClientInterceptorFactoryProtocol? { get }

  func makeCreateSessionCall(
    _ request: Aria_CreateSessionRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Aria_CreateSessionRequest, Aria_Session>

  func makeGetSessionCall(
    _ request: Aria_GetSessionRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Aria_GetSessionRequest, Aria_Session>

  func makeExecuteTurnCall(
    _ request: Aria_ExecuteTurnRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncServerStreamingCall<Aria_ExecuteTurnRequest, Aria_TurnOutput>
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension Aria_SessionServiceAsyncClientProtocol {
  public static var serviceDescriptor: GRPCServiceDescriptor {
    return Aria_SessionServiceClientMetadata.serviceDescriptor
  }

  public var interceptors: Aria_SessionServiceClientInterceptorFactoryProtocol? {
    return nil
  }

  public func makeCreateSessionCall(
    _ request: Aria_CreateSessionRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Aria_CreateSessionRequest, Aria_Session> {
    return self.makeAsyncUnaryCall(
      path: Aria_SessionServiceClientMetadata.Methods.createSession.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeCreateSessionInterceptors() ?? []
    )
  }

  public func makeGetSessionCall(
    _ request: Aria_GetSessionRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Aria_GetSessionRequest, Aria_Session> {
    return self.makeAsyncUnaryCall(
      path: Aria_SessionServiceClientMetadata.Methods.getSession.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeGetSessionInterceptors() ?? []
    )
  }

  public func makeExecuteTurnCall(
    _ request: Aria_ExecuteTurnRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncServerStreamingCall<Aria_ExecuteTurnRequest, Aria_TurnOutput> {
    return self.makeAsyncServerStreamingCall(
      path: Aria_SessionServiceClientMetadata.Methods.executeTurn.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeExecuteTurnInterceptors() ?? []
    )
  }
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension Aria_SessionServiceAsyncClientProtocol {
  public func createSession(
    _ request: Aria_CreateSessionRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Aria_Session {
    return try await self.performAsyncUnaryCall(
      path: Aria_SessionServiceClientMetadata.Methods.createSession.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeCreateSessionInterceptors() ?? []
    )
  }

  public func getSession(
    _ request: Aria_GetSessionRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Aria_Session {
    return try await self.performAsyncUnaryCall(
      path: Aria_SessionServiceClientMetadata.Methods.getSession.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeGetSessionInterceptors() ?? []
    )
  }

  public func executeTurn(
    _ request: Aria_ExecuteTurnRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncResponseStream<Aria_TurnOutput> {
    return self.performAsyncServerStreamingCall(
      path: Aria_SessionServiceClientMetadata.Methods.executeTurn.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeExecuteTurnInterceptors() ?? []
    )
  }
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
public struct Aria_SessionServiceAsyncClient: Aria_SessionServiceAsyncClientProtocol {
  public var channel: GRPCChannel
  public var defaultCallOptions: CallOptions
  public var interceptors: Aria_SessionServiceClientInterceptorFactoryProtocol?

  public init(
    channel: GRPCChannel,
    defaultCallOptions: CallOptions = CallOptions(),
    interceptors: Aria_SessionServiceClientInterceptorFactoryProtocol? = nil
  ) {
    self.channel = channel
    self.defaultCallOptions = defaultCallOptions
    self.interceptors = interceptors
  }
}

public protocol Aria_SessionServiceClientInterceptorFactoryProtocol: Sendable {

  /// - Returns: Interceptors to use when invoking 'createSession'.
  func makeCreateSessionInterceptors() -> [ClientInterceptor<Aria_CreateSessionRequest, Aria_Session>]

  /// - Returns: Interceptors to use when invoking 'getSession'.
  func makeGetSessionInterceptors() -> [ClientInterceptor<Aria_GetSessionRequest, Aria_Session>]

  /// - Returns: Interceptors to use when invoking 'executeTurn'.
  func makeExecuteTurnInterceptors() -> [ClientInterceptor<Aria_ExecuteTurnRequest, Aria_TurnOutput>]
}

public enum Aria_SessionServiceClientMetadata {
  public static let serviceDescriptor = GRPCServiceDescriptor(
    name: "SessionService",
    fullName: "aria.SessionService",
    methods: [
      Aria_SessionServiceClientMetadata.Methods.createSession,
      Aria_SessionServiceClientMetadata.Methods.getSession,
      Aria_SessionServiceClientMetadata.Methods.executeTurn,
    ]
  )

  public enum Methods {
    public static let createSession = GRPCMethodDescriptor(
      name: "CreateSession",
      path: "/aria.SessionService/CreateSession",
      type: GRPCCallType.unary
    )

    public static let getSession = GRPCMethodDescriptor(
      name: "GetSession",
      path: "/aria.SessionService/GetSession",
      type: GRPCCallType.unary
    )

    public static let executeTurn = GRPCMethodDescriptor(
      name: "ExecuteTurn",
      path: "/aria.SessionService/ExecuteTurn",
      type: GRPCCallType.serverStreaming
    )
  }
}

/// Service for direct, low-level management of containers.
/// Wraps the underlying quilt daemon.
///
/// Usage: instantiate `Aria_ContainerServiceClient`, then call methods of this protocol to make API calls.
public protocol Aria_ContainerServiceClientProtocol: GRPCClient {
  var serviceName: String { get }
  var interceptors: Aria_ContainerServiceClientInterceptorFactoryProtocol? { get }

  func createContainer(
    _ request: Aria_CreateContainerRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Aria_CreateContainerRequest, Aria_Container>

  func startContainer(
    _ request: Aria_StartContainerRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Aria_StartContainerRequest, Aria_StartContainerResponse>

  func stopContainer(
    _ request: Aria_StopContainerRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Aria_StopContainerRequest, Aria_StopContainerResponse>

  func removeContainer(
    _ request: Aria_RemoveContainerRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Aria_RemoveContainerRequest, Aria_RemoveContainerResponse>

  func getContainer(
    _ request: Aria_GetContainerRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Aria_GetContainerRequest, Aria_Container>

  func listContainers(
    _ request: Aria_ListContainersRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Aria_ListContainersRequest, Aria_ListContainersResponse>

  func streamContainerLogs(
    _ request: Aria_StreamContainerLogsRequest,
    callOptions: CallOptions?,
    handler: @escaping (Aria_ContainerLog) -> Void
  ) -> ServerStreamingCall<Aria_StreamContainerLogsRequest, Aria_ContainerLog>
}

extension Aria_ContainerServiceClientProtocol {
  public var serviceName: String {
    return "aria.ContainerService"
  }

  /// Unary call to CreateContainer
  ///
  /// - Parameters:
  ///   - request: Request to send to CreateContainer.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func createContainer(
    _ request: Aria_CreateContainerRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Aria_CreateContainerRequest, Aria_Container> {
    return self.makeUnaryCall(
      path: Aria_ContainerServiceClientMetadata.Methods.createContainer.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeCreateContainerInterceptors() ?? []
    )
  }

  /// Unary call to StartContainer
  ///
  /// - Parameters:
  ///   - request: Request to send to StartContainer.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func startContainer(
    _ request: Aria_StartContainerRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Aria_StartContainerRequest, Aria_StartContainerResponse> {
    return self.makeUnaryCall(
      path: Aria_ContainerServiceClientMetadata.Methods.startContainer.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeStartContainerInterceptors() ?? []
    )
  }

  /// Unary call to StopContainer
  ///
  /// - Parameters:
  ///   - request: Request to send to StopContainer.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func stopContainer(
    _ request: Aria_StopContainerRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Aria_StopContainerRequest, Aria_StopContainerResponse> {
    return self.makeUnaryCall(
      path: Aria_ContainerServiceClientMetadata.Methods.stopContainer.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeStopContainerInterceptors() ?? []
    )
  }

  /// Unary call to RemoveContainer
  ///
  /// - Parameters:
  ///   - request: Request to send to RemoveContainer.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func removeContainer(
    _ request: Aria_RemoveContainerRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Aria_RemoveContainerRequest, Aria_RemoveContainerResponse> {
    return self.makeUnaryCall(
      path: Aria_ContainerServiceClientMetadata.Methods.removeContainer.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeRemoveContainerInterceptors() ?? []
    )
  }

  /// Unary call to GetContainer
  ///
  /// - Parameters:
  ///   - request: Request to send to GetContainer.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func getContainer(
    _ request: Aria_GetContainerRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Aria_GetContainerRequest, Aria_Container> {
    return self.makeUnaryCall(
      path: Aria_ContainerServiceClientMetadata.Methods.getContainer.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeGetContainerInterceptors() ?? []
    )
  }

  /// Unary call to ListContainers
  ///
  /// - Parameters:
  ///   - request: Request to send to ListContainers.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func listContainers(
    _ request: Aria_ListContainersRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Aria_ListContainersRequest, Aria_ListContainersResponse> {
    return self.makeUnaryCall(
      path: Aria_ContainerServiceClientMetadata.Methods.listContainers.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeListContainersInterceptors() ?? []
    )
  }

  /// Server streaming call to StreamContainerLogs
  ///
  /// - Parameters:
  ///   - request: Request to send to StreamContainerLogs.
  ///   - callOptions: Call options.
  ///   - handler: A closure called when each response is received from the server.
  /// - Returns: A `ServerStreamingCall` with futures for the metadata and status.
  public func streamContainerLogs(
    _ request: Aria_StreamContainerLogsRequest,
    callOptions: CallOptions? = nil,
    handler: @escaping (Aria_ContainerLog) -> Void
  ) -> ServerStreamingCall<Aria_StreamContainerLogsRequest, Aria_ContainerLog> {
    return self.makeServerStreamingCall(
      path: Aria_ContainerServiceClientMetadata.Methods.streamContainerLogs.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeStreamContainerLogsInterceptors() ?? [],
      handler: handler
    )
  }
}

@available(*, deprecated)
extension Aria_ContainerServiceClient: @unchecked Sendable {}

@available(*, deprecated, renamed: "Aria_ContainerServiceNIOClient")
public final class Aria_ContainerServiceClient: Aria_ContainerServiceClientProtocol {
  private let lock = Lock()
  private var _defaultCallOptions: CallOptions
  private var _interceptors: Aria_ContainerServiceClientInterceptorFactoryProtocol?
  public let channel: GRPCChannel
  public var defaultCallOptions: CallOptions {
    get { self.lock.withLock { return self._defaultCallOptions } }
    set { self.lock.withLockVoid { self._defaultCallOptions = newValue } }
  }
  public var interceptors: Aria_ContainerServiceClientInterceptorFactoryProtocol? {
    get { self.lock.withLock { return self._interceptors } }
    set { self.lock.withLockVoid { self._interceptors = newValue } }
  }

  /// Creates a client for the aria.ContainerService service.
  ///
  /// - Parameters:
  ///   - channel: `GRPCChannel` to the service host.
  ///   - defaultCallOptions: Options to use for each service call if the user doesn't provide them.
  ///   - interceptors: A factory providing interceptors for each RPC.
  public init(
    channel: GRPCChannel,
    defaultCallOptions: CallOptions = CallOptions(),
    interceptors: Aria_ContainerServiceClientInterceptorFactoryProtocol? = nil
  ) {
    self.channel = channel
    self._defaultCallOptions = defaultCallOptions
    self._interceptors = interceptors
  }
}

public struct Aria_ContainerServiceNIOClient: Aria_ContainerServiceClientProtocol {
  public var channel: GRPCChannel
  public var defaultCallOptions: CallOptions
  public var interceptors: Aria_ContainerServiceClientInterceptorFactoryProtocol?

  /// Creates a client for the aria.ContainerService service.
  ///
  /// - Parameters:
  ///   - channel: `GRPCChannel` to the service host.
  ///   - defaultCallOptions: Options to use for each service call if the user doesn't provide them.
  ///   - interceptors: A factory providing interceptors for each RPC.
  public init(
    channel: GRPCChannel,
    defaultCallOptions: CallOptions = CallOptions(),
    interceptors: Aria_ContainerServiceClientInterceptorFactoryProtocol? = nil
  ) {
    self.channel = channel
    self.defaultCallOptions = defaultCallOptions
    self.interceptors = interceptors
  }
}

/// Service for direct, low-level management of containers.
/// Wraps the underlying quilt daemon.
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
public protocol Aria_ContainerServiceAsyncClientProtocol: GRPCClient {
  static var serviceDescriptor: GRPCServiceDescriptor { get }
  var interceptors: Aria_ContainerServiceClientInterceptorFactoryProtocol? { get }

  func makeCreateContainerCall(
    _ request: Aria_CreateContainerRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Aria_CreateContainerRequest, Aria_Container>

  func makeStartContainerCall(
    _ request: Aria_StartContainerRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Aria_StartContainerRequest, Aria_StartContainerResponse>

  func makeStopContainerCall(
    _ request: Aria_StopContainerRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Aria_StopContainerRequest, Aria_StopContainerResponse>

  func makeRemoveContainerCall(
    _ request: Aria_RemoveContainerRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Aria_RemoveContainerRequest, Aria_RemoveContainerResponse>

  func makeGetContainerCall(
    _ request: Aria_GetContainerRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Aria_GetContainerRequest, Aria_Container>

  func makeListContainersCall(
    _ request: Aria_ListContainersRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Aria_ListContainersRequest, Aria_ListContainersResponse>

  func makeStreamContainerLogsCall(
    _ request: Aria_StreamContainerLogsRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncServerStreamingCall<Aria_StreamContainerLogsRequest, Aria_ContainerLog>
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension Aria_ContainerServiceAsyncClientProtocol {
  public static var serviceDescriptor: GRPCServiceDescriptor {
    return Aria_ContainerServiceClientMetadata.serviceDescriptor
  }

  public var interceptors: Aria_ContainerServiceClientInterceptorFactoryProtocol? {
    return nil
  }

  public func makeCreateContainerCall(
    _ request: Aria_CreateContainerRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Aria_CreateContainerRequest, Aria_Container> {
    return self.makeAsyncUnaryCall(
      path: Aria_ContainerServiceClientMetadata.Methods.createContainer.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeCreateContainerInterceptors() ?? []
    )
  }

  public func makeStartContainerCall(
    _ request: Aria_StartContainerRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Aria_StartContainerRequest, Aria_StartContainerResponse> {
    return self.makeAsyncUnaryCall(
      path: Aria_ContainerServiceClientMetadata.Methods.startContainer.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeStartContainerInterceptors() ?? []
    )
  }

  public func makeStopContainerCall(
    _ request: Aria_StopContainerRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Aria_StopContainerRequest, Aria_StopContainerResponse> {
    return self.makeAsyncUnaryCall(
      path: Aria_ContainerServiceClientMetadata.Methods.stopContainer.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeStopContainerInterceptors() ?? []
    )
  }

  public func makeRemoveContainerCall(
    _ request: Aria_RemoveContainerRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Aria_RemoveContainerRequest, Aria_RemoveContainerResponse> {
    return self.makeAsyncUnaryCall(
      path: Aria_ContainerServiceClientMetadata.Methods.removeContainer.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeRemoveContainerInterceptors() ?? []
    )
  }

  public func makeGetContainerCall(
    _ request: Aria_GetContainerRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Aria_GetContainerRequest, Aria_Container> {
    return self.makeAsyncUnaryCall(
      path: Aria_ContainerServiceClientMetadata.Methods.getContainer.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeGetContainerInterceptors() ?? []
    )
  }

  public func makeListContainersCall(
    _ request: Aria_ListContainersRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Aria_ListContainersRequest, Aria_ListContainersResponse> {
    return self.makeAsyncUnaryCall(
      path: Aria_ContainerServiceClientMetadata.Methods.listContainers.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeListContainersInterceptors() ?? []
    )
  }

  public func makeStreamContainerLogsCall(
    _ request: Aria_StreamContainerLogsRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncServerStreamingCall<Aria_StreamContainerLogsRequest, Aria_ContainerLog> {
    return self.makeAsyncServerStreamingCall(
      path: Aria_ContainerServiceClientMetadata.Methods.streamContainerLogs.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeStreamContainerLogsInterceptors() ?? []
    )
  }
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension Aria_ContainerServiceAsyncClientProtocol {
  public func createContainer(
    _ request: Aria_CreateContainerRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Aria_Container {
    return try await self.performAsyncUnaryCall(
      path: Aria_ContainerServiceClientMetadata.Methods.createContainer.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeCreateContainerInterceptors() ?? []
    )
  }

  public func startContainer(
    _ request: Aria_StartContainerRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Aria_StartContainerResponse {
    return try await self.performAsyncUnaryCall(
      path: Aria_ContainerServiceClientMetadata.Methods.startContainer.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeStartContainerInterceptors() ?? []
    )
  }

  public func stopContainer(
    _ request: Aria_StopContainerRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Aria_StopContainerResponse {
    return try await self.performAsyncUnaryCall(
      path: Aria_ContainerServiceClientMetadata.Methods.stopContainer.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeStopContainerInterceptors() ?? []
    )
  }

  public func removeContainer(
    _ request: Aria_RemoveContainerRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Aria_RemoveContainerResponse {
    return try await self.performAsyncUnaryCall(
      path: Aria_ContainerServiceClientMetadata.Methods.removeContainer.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeRemoveContainerInterceptors() ?? []
    )
  }

  public func getContainer(
    _ request: Aria_GetContainerRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Aria_Container {
    return try await self.performAsyncUnaryCall(
      path: Aria_ContainerServiceClientMetadata.Methods.getContainer.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeGetContainerInterceptors() ?? []
    )
  }

  public func listContainers(
    _ request: Aria_ListContainersRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Aria_ListContainersResponse {
    return try await self.performAsyncUnaryCall(
      path: Aria_ContainerServiceClientMetadata.Methods.listContainers.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeListContainersInterceptors() ?? []
    )
  }

  public func streamContainerLogs(
    _ request: Aria_StreamContainerLogsRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncResponseStream<Aria_ContainerLog> {
    return self.performAsyncServerStreamingCall(
      path: Aria_ContainerServiceClientMetadata.Methods.streamContainerLogs.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeStreamContainerLogsInterceptors() ?? []
    )
  }
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
public struct Aria_ContainerServiceAsyncClient: Aria_ContainerServiceAsyncClientProtocol {
  public var channel: GRPCChannel
  public var defaultCallOptions: CallOptions
  public var interceptors: Aria_ContainerServiceClientInterceptorFactoryProtocol?

  public init(
    channel: GRPCChannel,
    defaultCallOptions: CallOptions = CallOptions(),
    interceptors: Aria_ContainerServiceClientInterceptorFactoryProtocol? = nil
  ) {
    self.channel = channel
    self.defaultCallOptions = defaultCallOptions
    self.interceptors = interceptors
  }
}

public protocol Aria_ContainerServiceClientInterceptorFactoryProtocol: Sendable {

  /// - Returns: Interceptors to use when invoking 'createContainer'.
  func makeCreateContainerInterceptors() -> [ClientInterceptor<Aria_CreateContainerRequest, Aria_Container>]

  /// - Returns: Interceptors to use when invoking 'startContainer'.
  func makeStartContainerInterceptors() -> [ClientInterceptor<Aria_StartContainerRequest, Aria_StartContainerResponse>]

  /// - Returns: Interceptors to use when invoking 'stopContainer'.
  func makeStopContainerInterceptors() -> [ClientInterceptor<Aria_StopContainerRequest, Aria_StopContainerResponse>]

  /// - Returns: Interceptors to use when invoking 'removeContainer'.
  func makeRemoveContainerInterceptors() -> [ClientInterceptor<Aria_RemoveContainerRequest, Aria_RemoveContainerResponse>]

  /// - Returns: Interceptors to use when invoking 'getContainer'.
  func makeGetContainerInterceptors() -> [ClientInterceptor<Aria_GetContainerRequest, Aria_Container>]

  /// - Returns: Interceptors to use when invoking 'listContainers'.
  func makeListContainersInterceptors() -> [ClientInterceptor<Aria_ListContainersRequest, Aria_ListContainersResponse>]

  /// - Returns: Interceptors to use when invoking 'streamContainerLogs'.
  func makeStreamContainerLogsInterceptors() -> [ClientInterceptor<Aria_StreamContainerLogsRequest, Aria_ContainerLog>]
}

public enum Aria_ContainerServiceClientMetadata {
  public static let serviceDescriptor = GRPCServiceDescriptor(
    name: "ContainerService",
    fullName: "aria.ContainerService",
    methods: [
      Aria_ContainerServiceClientMetadata.Methods.createContainer,
      Aria_ContainerServiceClientMetadata.Methods.startContainer,
      Aria_ContainerServiceClientMetadata.Methods.stopContainer,
      Aria_ContainerServiceClientMetadata.Methods.removeContainer,
      Aria_ContainerServiceClientMetadata.Methods.getContainer,
      Aria_ContainerServiceClientMetadata.Methods.listContainers,
      Aria_ContainerServiceClientMetadata.Methods.streamContainerLogs,
    ]
  )

  public enum Methods {
    public static let createContainer = GRPCMethodDescriptor(
      name: "CreateContainer",
      path: "/aria.ContainerService/CreateContainer",
      type: GRPCCallType.unary
    )

    public static let startContainer = GRPCMethodDescriptor(
      name: "StartContainer",
      path: "/aria.ContainerService/StartContainer",
      type: GRPCCallType.unary
    )

    public static let stopContainer = GRPCMethodDescriptor(
      name: "StopContainer",
      path: "/aria.ContainerService/StopContainer",
      type: GRPCCallType.unary
    )

    public static let removeContainer = GRPCMethodDescriptor(
      name: "RemoveContainer",
      path: "/aria.ContainerService/RemoveContainer",
      type: GRPCCallType.unary
    )

    public static let getContainer = GRPCMethodDescriptor(
      name: "GetContainer",
      path: "/aria.ContainerService/GetContainer",
      type: GRPCCallType.unary
    )

    public static let listContainers = GRPCMethodDescriptor(
      name: "ListContainers",
      path: "/aria.ContainerService/ListContainers",
      type: GRPCCallType.unary
    )

    public static let streamContainerLogs = GRPCMethodDescriptor(
      name: "StreamContainerLogs",
      path: "/aria.ContainerService/StreamContainerLogs",
      type: GRPCCallType.serverStreaming
    )
  }
}

/// Service for streaming real-time events from the runtime to the client.
///
/// Usage: instantiate `Aria_NotificationServiceClient`, then call methods of this protocol to make API calls.
public protocol Aria_NotificationServiceClientProtocol: GRPCClient {
  var serviceName: String { get }
  var interceptors: Aria_NotificationServiceClientInterceptorFactoryProtocol? { get }

  func streamNotifications(
    _ request: Aria_StreamNotificationsRequest,
    callOptions: CallOptions?,
    handler: @escaping (Aria_Notification) -> Void
  ) -> ServerStreamingCall<Aria_StreamNotificationsRequest, Aria_Notification>
}

extension Aria_NotificationServiceClientProtocol {
  public var serviceName: String {
    return "aria.NotificationService"
  }

  /// Establishes a persistent stream for the client to receive notifications.
  ///
  /// - Parameters:
  ///   - request: Request to send to StreamNotifications.
  ///   - callOptions: Call options.
  ///   - handler: A closure called when each response is received from the server.
  /// - Returns: A `ServerStreamingCall` with futures for the metadata and status.
  public func streamNotifications(
    _ request: Aria_StreamNotificationsRequest,
    callOptions: CallOptions? = nil,
    handler: @escaping (Aria_Notification) -> Void
  ) -> ServerStreamingCall<Aria_StreamNotificationsRequest, Aria_Notification> {
    return self.makeServerStreamingCall(
      path: Aria_NotificationServiceClientMetadata.Methods.streamNotifications.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeStreamNotificationsInterceptors() ?? [],
      handler: handler
    )
  }
}

@available(*, deprecated)
extension Aria_NotificationServiceClient: @unchecked Sendable {}

@available(*, deprecated, renamed: "Aria_NotificationServiceNIOClient")
public final class Aria_NotificationServiceClient: Aria_NotificationServiceClientProtocol {
  private let lock = Lock()
  private var _defaultCallOptions: CallOptions
  private var _interceptors: Aria_NotificationServiceClientInterceptorFactoryProtocol?
  public let channel: GRPCChannel
  public var defaultCallOptions: CallOptions {
    get { self.lock.withLock { return self._defaultCallOptions } }
    set { self.lock.withLockVoid { self._defaultCallOptions = newValue } }
  }
  public var interceptors: Aria_NotificationServiceClientInterceptorFactoryProtocol? {
    get { self.lock.withLock { return self._interceptors } }
    set { self.lock.withLockVoid { self._interceptors = newValue } }
  }

  /// Creates a client for the aria.NotificationService service.
  ///
  /// - Parameters:
  ///   - channel: `GRPCChannel` to the service host.
  ///   - defaultCallOptions: Options to use for each service call if the user doesn't provide them.
  ///   - interceptors: A factory providing interceptors for each RPC.
  public init(
    channel: GRPCChannel,
    defaultCallOptions: CallOptions = CallOptions(),
    interceptors: Aria_NotificationServiceClientInterceptorFactoryProtocol? = nil
  ) {
    self.channel = channel
    self._defaultCallOptions = defaultCallOptions
    self._interceptors = interceptors
  }
}

public struct Aria_NotificationServiceNIOClient: Aria_NotificationServiceClientProtocol {
  public var channel: GRPCChannel
  public var defaultCallOptions: CallOptions
  public var interceptors: Aria_NotificationServiceClientInterceptorFactoryProtocol?

  /// Creates a client for the aria.NotificationService service.
  ///
  /// - Parameters:
  ///   - channel: `GRPCChannel` to the service host.
  ///   - defaultCallOptions: Options to use for each service call if the user doesn't provide them.
  ///   - interceptors: A factory providing interceptors for each RPC.
  public init(
    channel: GRPCChannel,
    defaultCallOptions: CallOptions = CallOptions(),
    interceptors: Aria_NotificationServiceClientInterceptorFactoryProtocol? = nil
  ) {
    self.channel = channel
    self.defaultCallOptions = defaultCallOptions
    self.interceptors = interceptors
  }
}

/// Service for streaming real-time events from the runtime to the client.
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
public protocol Aria_NotificationServiceAsyncClientProtocol: GRPCClient {
  static var serviceDescriptor: GRPCServiceDescriptor { get }
  var interceptors: Aria_NotificationServiceClientInterceptorFactoryProtocol? { get }

  func makeStreamNotificationsCall(
    _ request: Aria_StreamNotificationsRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncServerStreamingCall<Aria_StreamNotificationsRequest, Aria_Notification>
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension Aria_NotificationServiceAsyncClientProtocol {
  public static var serviceDescriptor: GRPCServiceDescriptor {
    return Aria_NotificationServiceClientMetadata.serviceDescriptor
  }

  public var interceptors: Aria_NotificationServiceClientInterceptorFactoryProtocol? {
    return nil
  }

  public func makeStreamNotificationsCall(
    _ request: Aria_StreamNotificationsRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncServerStreamingCall<Aria_StreamNotificationsRequest, Aria_Notification> {
    return self.makeAsyncServerStreamingCall(
      path: Aria_NotificationServiceClientMetadata.Methods.streamNotifications.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeStreamNotificationsInterceptors() ?? []
    )
  }
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension Aria_NotificationServiceAsyncClientProtocol {
  public func streamNotifications(
    _ request: Aria_StreamNotificationsRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncResponseStream<Aria_Notification> {
    return self.performAsyncServerStreamingCall(
      path: Aria_NotificationServiceClientMetadata.Methods.streamNotifications.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeStreamNotificationsInterceptors() ?? []
    )
  }
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
public struct Aria_NotificationServiceAsyncClient: Aria_NotificationServiceAsyncClientProtocol {
  public var channel: GRPCChannel
  public var defaultCallOptions: CallOptions
  public var interceptors: Aria_NotificationServiceClientInterceptorFactoryProtocol?

  public init(
    channel: GRPCChannel,
    defaultCallOptions: CallOptions = CallOptions(),
    interceptors: Aria_NotificationServiceClientInterceptorFactoryProtocol? = nil
  ) {
    self.channel = channel
    self.defaultCallOptions = defaultCallOptions
    self.interceptors = interceptors
  }
}

public protocol Aria_NotificationServiceClientInterceptorFactoryProtocol: Sendable {

  /// - Returns: Interceptors to use when invoking 'streamNotifications'.
  func makeStreamNotificationsInterceptors() -> [ClientInterceptor<Aria_StreamNotificationsRequest, Aria_Notification>]
}

public enum Aria_NotificationServiceClientMetadata {
  public static let serviceDescriptor = GRPCServiceDescriptor(
    name: "NotificationService",
    fullName: "aria.NotificationService",
    methods: [
      Aria_NotificationServiceClientMetadata.Methods.streamNotifications,
    ]
  )

  public enum Methods {
    public static let streamNotifications = GRPCMethodDescriptor(
      name: "StreamNotifications",
      path: "/aria.NotificationService/StreamNotifications",
      type: GRPCCallType.serverStreaming
    )
  }
}

/// Service for managing and deploying .aria bundles.
///
/// Usage: instantiate `Aria_BundleServiceClient`, then call methods of this protocol to make API calls.
public protocol Aria_BundleServiceClientProtocol: GRPCClient {
  var serviceName: String { get }
  var interceptors: Aria_BundleServiceClientInterceptorFactoryProtocol? { get }

  func uploadBundle(
    callOptions: CallOptions?
  ) -> ClientStreamingCall<Aria_UploadBundleRequest, Aria_UploadBundleResponse>
}

extension Aria_BundleServiceClientProtocol {
  public var serviceName: String {
    return "aria.BundleService"
  }

  /// Uploads a bundle to the runtime via a client-side stream.
  /// The first message in the stream must be a `Metadata` message.
  /// All subsequent messages must be `Chunk` messages.
  ///
  /// Callers should use the `send` method on the returned object to send messages
  /// to the server. The caller should send an `.end` after the final message has been sent.
  ///
  /// - Parameters:
  ///   - callOptions: Call options.
  /// - Returns: A `ClientStreamingCall` with futures for the metadata, status and response.
  public func uploadBundle(
    callOptions: CallOptions? = nil
  ) -> ClientStreamingCall<Aria_UploadBundleRequest, Aria_UploadBundleResponse> {
    return self.makeClientStreamingCall(
      path: Aria_BundleServiceClientMetadata.Methods.uploadBundle.path,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeUploadBundleInterceptors() ?? []
    )
  }
}

@available(*, deprecated)
extension Aria_BundleServiceClient: @unchecked Sendable {}

@available(*, deprecated, renamed: "Aria_BundleServiceNIOClient")
public final class Aria_BundleServiceClient: Aria_BundleServiceClientProtocol {
  private let lock = Lock()
  private var _defaultCallOptions: CallOptions
  private var _interceptors: Aria_BundleServiceClientInterceptorFactoryProtocol?
  public let channel: GRPCChannel
  public var defaultCallOptions: CallOptions {
    get { self.lock.withLock { return self._defaultCallOptions } }
    set { self.lock.withLockVoid { self._defaultCallOptions = newValue } }
  }
  public var interceptors: Aria_BundleServiceClientInterceptorFactoryProtocol? {
    get { self.lock.withLock { return self._interceptors } }
    set { self.lock.withLockVoid { self._interceptors = newValue } }
  }

  /// Creates a client for the aria.BundleService service.
  ///
  /// - Parameters:
  ///   - channel: `GRPCChannel` to the service host.
  ///   - defaultCallOptions: Options to use for each service call if the user doesn't provide them.
  ///   - interceptors: A factory providing interceptors for each RPC.
  public init(
    channel: GRPCChannel,
    defaultCallOptions: CallOptions = CallOptions(),
    interceptors: Aria_BundleServiceClientInterceptorFactoryProtocol? = nil
  ) {
    self.channel = channel
    self._defaultCallOptions = defaultCallOptions
    self._interceptors = interceptors
  }
}

public struct Aria_BundleServiceNIOClient: Aria_BundleServiceClientProtocol {
  public var channel: GRPCChannel
  public var defaultCallOptions: CallOptions
  public var interceptors: Aria_BundleServiceClientInterceptorFactoryProtocol?

  /// Creates a client for the aria.BundleService service.
  ///
  /// - Parameters:
  ///   - channel: `GRPCChannel` to the service host.
  ///   - defaultCallOptions: Options to use for each service call if the user doesn't provide them.
  ///   - interceptors: A factory providing interceptors for each RPC.
  public init(
    channel: GRPCChannel,
    defaultCallOptions: CallOptions = CallOptions(),
    interceptors: Aria_BundleServiceClientInterceptorFactoryProtocol? = nil
  ) {
    self.channel = channel
    self.defaultCallOptions = defaultCallOptions
    self.interceptors = interceptors
  }
}

/// Service for managing and deploying .aria bundles.
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
public protocol Aria_BundleServiceAsyncClientProtocol: GRPCClient {
  static var serviceDescriptor: GRPCServiceDescriptor { get }
  var interceptors: Aria_BundleServiceClientInterceptorFactoryProtocol? { get }

  func makeUploadBundleCall(
    callOptions: CallOptions?
  ) -> GRPCAsyncClientStreamingCall<Aria_UploadBundleRequest, Aria_UploadBundleResponse>
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension Aria_BundleServiceAsyncClientProtocol {
  public static var serviceDescriptor: GRPCServiceDescriptor {
    return Aria_BundleServiceClientMetadata.serviceDescriptor
  }

  public var interceptors: Aria_BundleServiceClientInterceptorFactoryProtocol? {
    return nil
  }

  public func makeUploadBundleCall(
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncClientStreamingCall<Aria_UploadBundleRequest, Aria_UploadBundleResponse> {
    return self.makeAsyncClientStreamingCall(
      path: Aria_BundleServiceClientMetadata.Methods.uploadBundle.path,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeUploadBundleInterceptors() ?? []
    )
  }
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension Aria_BundleServiceAsyncClientProtocol {
  public func uploadBundle<RequestStream>(
    _ requests: RequestStream,
    callOptions: CallOptions? = nil
  ) async throws -> Aria_UploadBundleResponse where RequestStream: Sequence, RequestStream.Element == Aria_UploadBundleRequest {
    return try await self.performAsyncClientStreamingCall(
      path: Aria_BundleServiceClientMetadata.Methods.uploadBundle.path,
      requests: requests,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeUploadBundleInterceptors() ?? []
    )
  }

  public func uploadBundle<RequestStream>(
    _ requests: RequestStream,
    callOptions: CallOptions? = nil
  ) async throws -> Aria_UploadBundleResponse where RequestStream: AsyncSequence & Sendable, RequestStream.Element == Aria_UploadBundleRequest {
    return try await self.performAsyncClientStreamingCall(
      path: Aria_BundleServiceClientMetadata.Methods.uploadBundle.path,
      requests: requests,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeUploadBundleInterceptors() ?? []
    )
  }
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
public struct Aria_BundleServiceAsyncClient: Aria_BundleServiceAsyncClientProtocol {
  public var channel: GRPCChannel
  public var defaultCallOptions: CallOptions
  public var interceptors: Aria_BundleServiceClientInterceptorFactoryProtocol?

  public init(
    channel: GRPCChannel,
    defaultCallOptions: CallOptions = CallOptions(),
    interceptors: Aria_BundleServiceClientInterceptorFactoryProtocol? = nil
  ) {
    self.channel = channel
    self.defaultCallOptions = defaultCallOptions
    self.interceptors = interceptors
  }
}

public protocol Aria_BundleServiceClientInterceptorFactoryProtocol: Sendable {

  /// - Returns: Interceptors to use when invoking 'uploadBundle'.
  func makeUploadBundleInterceptors() -> [ClientInterceptor<Aria_UploadBundleRequest, Aria_UploadBundleResponse>]
}

public enum Aria_BundleServiceClientMetadata {
  public static let serviceDescriptor = GRPCServiceDescriptor(
    name: "BundleService",
    fullName: "aria.BundleService",
    methods: [
      Aria_BundleServiceClientMetadata.Methods.uploadBundle,
    ]
  )

  public enum Methods {
    public static let uploadBundle = GRPCMethodDescriptor(
      name: "UploadBundle",
      path: "/aria.BundleService/UploadBundle",
      type: GRPCCallType.clientStreaming
    )
  }
}

/// Service for managing and interacting with long-running asynchronous tasks.
///
/// To build a server, implement a class that conforms to this protocol.
public protocol Aria_TaskServiceProvider: CallHandlerProvider {
  var interceptors: Aria_TaskServiceServerInterceptorFactoryProtocol? { get }

  /// Launches a new asynchronous task.
  func launchTask(request: Aria_LaunchTaskRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Aria_LaunchTaskResponse>

  /// Retrieves the current status and details of a task.
  func getTask(request: Aria_GetTaskRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Aria_Task>

  /// Lists tasks, with support for filtering and pagination.
  func listTasks(request: Aria_ListTasksRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Aria_ListTasksResponse>

  /// Streams the output (stdout/stderr) and progress of a running task.
  func streamTaskOutput(request: Aria_StreamTaskOutputRequest, context: StreamingResponseCallContext<Aria_TaskOutput>) -> EventLoopFuture<GRPCStatus>

  /// Cancels a pending or running task.
  func cancelTask(request: Aria_CancelTaskRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Aria_CancelTaskResponse>
}

extension Aria_TaskServiceProvider {
  public var serviceName: Substring {
    return Aria_TaskServiceServerMetadata.serviceDescriptor.fullName[...]
  }

  /// Determines, calls and returns the appropriate request handler, depending on the request's method.
  /// Returns nil for methods not handled by this service.
  public func handle(
    method name: Substring,
    context: CallHandlerContext
  ) -> GRPCServerHandlerProtocol? {
    switch name {
    case "LaunchTask":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Aria_LaunchTaskRequest>(),
        responseSerializer: ProtobufSerializer<Aria_LaunchTaskResponse>(),
        interceptors: self.interceptors?.makeLaunchTaskInterceptors() ?? [],
        userFunction: self.launchTask(request:context:)
      )

    case "GetTask":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Aria_GetTaskRequest>(),
        responseSerializer: ProtobufSerializer<Aria_Task>(),
        interceptors: self.interceptors?.makeGetTaskInterceptors() ?? [],
        userFunction: self.getTask(request:context:)
      )

    case "ListTasks":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Aria_ListTasksRequest>(),
        responseSerializer: ProtobufSerializer<Aria_ListTasksResponse>(),
        interceptors: self.interceptors?.makeListTasksInterceptors() ?? [],
        userFunction: self.listTasks(request:context:)
      )

    case "StreamTaskOutput":
      return ServerStreamingServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Aria_StreamTaskOutputRequest>(),
        responseSerializer: ProtobufSerializer<Aria_TaskOutput>(),
        interceptors: self.interceptors?.makeStreamTaskOutputInterceptors() ?? [],
        userFunction: self.streamTaskOutput(request:context:)
      )

    case "CancelTask":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Aria_CancelTaskRequest>(),
        responseSerializer: ProtobufSerializer<Aria_CancelTaskResponse>(),
        interceptors: self.interceptors?.makeCancelTaskInterceptors() ?? [],
        userFunction: self.cancelTask(request:context:)
      )

    default:
      return nil
    }
  }
}

/// Service for managing and interacting with long-running asynchronous tasks.
///
/// To implement a server, implement an object which conforms to this protocol.
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
public protocol Aria_TaskServiceAsyncProvider: CallHandlerProvider, Sendable {
  static var serviceDescriptor: GRPCServiceDescriptor { get }
  var interceptors: Aria_TaskServiceServerInterceptorFactoryProtocol? { get }

  /// Launches a new asynchronous task.
  func launchTask(
    request: Aria_LaunchTaskRequest,
    context: GRPCAsyncServerCallContext
  ) async throws -> Aria_LaunchTaskResponse

  /// Retrieves the current status and details of a task.
  func getTask(
    request: Aria_GetTaskRequest,
    context: GRPCAsyncServerCallContext
  ) async throws -> Aria_Task

  /// Lists tasks, with support for filtering and pagination.
  func listTasks(
    request: Aria_ListTasksRequest,
    context: GRPCAsyncServerCallContext
  ) async throws -> Aria_ListTasksResponse

  /// Streams the output (stdout/stderr) and progress of a running task.
  func streamTaskOutput(
    request: Aria_StreamTaskOutputRequest,
    responseStream: GRPCAsyncResponseStreamWriter<Aria_TaskOutput>,
    context: GRPCAsyncServerCallContext
  ) async throws

  /// Cancels a pending or running task.
  func cancelTask(
    request: Aria_CancelTaskRequest,
    context: GRPCAsyncServerCallContext
  ) async throws -> Aria_CancelTaskResponse
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension Aria_TaskServiceAsyncProvider {
  public static var serviceDescriptor: GRPCServiceDescriptor {
    return Aria_TaskServiceServerMetadata.serviceDescriptor
  }

  public var serviceName: Substring {
    return Aria_TaskServiceServerMetadata.serviceDescriptor.fullName[...]
  }

  public var interceptors: Aria_TaskServiceServerInterceptorFactoryProtocol? {
    return nil
  }

  public func handle(
    method name: Substring,
    context: CallHandlerContext
  ) -> GRPCServerHandlerProtocol? {
    switch name {
    case "LaunchTask":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Aria_LaunchTaskRequest>(),
        responseSerializer: ProtobufSerializer<Aria_LaunchTaskResponse>(),
        interceptors: self.interceptors?.makeLaunchTaskInterceptors() ?? [],
        wrapping: { try await self.launchTask(request: $0, context: $1) }
      )

    case "GetTask":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Aria_GetTaskRequest>(),
        responseSerializer: ProtobufSerializer<Aria_Task>(),
        interceptors: self.interceptors?.makeGetTaskInterceptors() ?? [],
        wrapping: { try await self.getTask(request: $0, context: $1) }
      )

    case "ListTasks":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Aria_ListTasksRequest>(),
        responseSerializer: ProtobufSerializer<Aria_ListTasksResponse>(),
        interceptors: self.interceptors?.makeListTasksInterceptors() ?? [],
        wrapping: { try await self.listTasks(request: $0, context: $1) }
      )

    case "StreamTaskOutput":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Aria_StreamTaskOutputRequest>(),
        responseSerializer: ProtobufSerializer<Aria_TaskOutput>(),
        interceptors: self.interceptors?.makeStreamTaskOutputInterceptors() ?? [],
        wrapping: { try await self.streamTaskOutput(request: $0, responseStream: $1, context: $2) }
      )

    case "CancelTask":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Aria_CancelTaskRequest>(),
        responseSerializer: ProtobufSerializer<Aria_CancelTaskResponse>(),
        interceptors: self.interceptors?.makeCancelTaskInterceptors() ?? [],
        wrapping: { try await self.cancelTask(request: $0, context: $1) }
      )

    default:
      return nil
    }
  }
}

public protocol Aria_TaskServiceServerInterceptorFactoryProtocol: Sendable {

  /// - Returns: Interceptors to use when handling 'launchTask'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeLaunchTaskInterceptors() -> [ServerInterceptor<Aria_LaunchTaskRequest, Aria_LaunchTaskResponse>]

  /// - Returns: Interceptors to use when handling 'getTask'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeGetTaskInterceptors() -> [ServerInterceptor<Aria_GetTaskRequest, Aria_Task>]

  /// - Returns: Interceptors to use when handling 'listTasks'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeListTasksInterceptors() -> [ServerInterceptor<Aria_ListTasksRequest, Aria_ListTasksResponse>]

  /// - Returns: Interceptors to use when handling 'streamTaskOutput'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeStreamTaskOutputInterceptors() -> [ServerInterceptor<Aria_StreamTaskOutputRequest, Aria_TaskOutput>]

  /// - Returns: Interceptors to use when handling 'cancelTask'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeCancelTaskInterceptors() -> [ServerInterceptor<Aria_CancelTaskRequest, Aria_CancelTaskResponse>]
}

public enum Aria_TaskServiceServerMetadata {
  public static let serviceDescriptor = GRPCServiceDescriptor(
    name: "TaskService",
    fullName: "aria.TaskService",
    methods: [
      Aria_TaskServiceServerMetadata.Methods.launchTask,
      Aria_TaskServiceServerMetadata.Methods.getTask,
      Aria_TaskServiceServerMetadata.Methods.listTasks,
      Aria_TaskServiceServerMetadata.Methods.streamTaskOutput,
      Aria_TaskServiceServerMetadata.Methods.cancelTask,
    ]
  )

  public enum Methods {
    public static let launchTask = GRPCMethodDescriptor(
      name: "LaunchTask",
      path: "/aria.TaskService/LaunchTask",
      type: GRPCCallType.unary
    )

    public static let getTask = GRPCMethodDescriptor(
      name: "GetTask",
      path: "/aria.TaskService/GetTask",
      type: GRPCCallType.unary
    )

    public static let listTasks = GRPCMethodDescriptor(
      name: "ListTasks",
      path: "/aria.TaskService/ListTasks",
      type: GRPCCallType.unary
    )

    public static let streamTaskOutput = GRPCMethodDescriptor(
      name: "StreamTaskOutput",
      path: "/aria.TaskService/StreamTaskOutput",
      type: GRPCCallType.serverStreaming
    )

    public static let cancelTask = GRPCMethodDescriptor(
      name: "CancelTask",
      path: "/aria.TaskService/CancelTask",
      type: GRPCCallType.unary
    )
  }
}
/// Service for managing user sessions and conversations.
///
/// To build a server, implement a class that conforms to this protocol.
public protocol Aria_SessionServiceProvider: CallHandlerProvider {
  var interceptors: Aria_SessionServiceServerInterceptorFactoryProtocol? { get }

  /// Creates a new session for a user.
  func createSession(request: Aria_CreateSessionRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Aria_Session>

  /// Gets details for a specific session.
  func getSession(request: Aria_GetSessionRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Aria_Session>

  /// Executes a "turn" in a conversation within a session.
  func executeTurn(request: Aria_ExecuteTurnRequest, context: StreamingResponseCallContext<Aria_TurnOutput>) -> EventLoopFuture<GRPCStatus>
}

extension Aria_SessionServiceProvider {
  public var serviceName: Substring {
    return Aria_SessionServiceServerMetadata.serviceDescriptor.fullName[...]
  }

  /// Determines, calls and returns the appropriate request handler, depending on the request's method.
  /// Returns nil for methods not handled by this service.
  public func handle(
    method name: Substring,
    context: CallHandlerContext
  ) -> GRPCServerHandlerProtocol? {
    switch name {
    case "CreateSession":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Aria_CreateSessionRequest>(),
        responseSerializer: ProtobufSerializer<Aria_Session>(),
        interceptors: self.interceptors?.makeCreateSessionInterceptors() ?? [],
        userFunction: self.createSession(request:context:)
      )

    case "GetSession":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Aria_GetSessionRequest>(),
        responseSerializer: ProtobufSerializer<Aria_Session>(),
        interceptors: self.interceptors?.makeGetSessionInterceptors() ?? [],
        userFunction: self.getSession(request:context:)
      )

    case "ExecuteTurn":
      return ServerStreamingServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Aria_ExecuteTurnRequest>(),
        responseSerializer: ProtobufSerializer<Aria_TurnOutput>(),
        interceptors: self.interceptors?.makeExecuteTurnInterceptors() ?? [],
        userFunction: self.executeTurn(request:context:)
      )

    default:
      return nil
    }
  }
}

/// Service for managing user sessions and conversations.
///
/// To implement a server, implement an object which conforms to this protocol.
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
public protocol Aria_SessionServiceAsyncProvider: CallHandlerProvider, Sendable {
  static var serviceDescriptor: GRPCServiceDescriptor { get }
  var interceptors: Aria_SessionServiceServerInterceptorFactoryProtocol? { get }

  /// Creates a new session for a user.
  func createSession(
    request: Aria_CreateSessionRequest,
    context: GRPCAsyncServerCallContext
  ) async throws -> Aria_Session

  /// Gets details for a specific session.
  func getSession(
    request: Aria_GetSessionRequest,
    context: GRPCAsyncServerCallContext
  ) async throws -> Aria_Session

  /// Executes a "turn" in a conversation within a session.
  func executeTurn(
    request: Aria_ExecuteTurnRequest,
    responseStream: GRPCAsyncResponseStreamWriter<Aria_TurnOutput>,
    context: GRPCAsyncServerCallContext
  ) async throws
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension Aria_SessionServiceAsyncProvider {
  public static var serviceDescriptor: GRPCServiceDescriptor {
    return Aria_SessionServiceServerMetadata.serviceDescriptor
  }

  public var serviceName: Substring {
    return Aria_SessionServiceServerMetadata.serviceDescriptor.fullName[...]
  }

  public var interceptors: Aria_SessionServiceServerInterceptorFactoryProtocol? {
    return nil
  }

  public func handle(
    method name: Substring,
    context: CallHandlerContext
  ) -> GRPCServerHandlerProtocol? {
    switch name {
    case "CreateSession":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Aria_CreateSessionRequest>(),
        responseSerializer: ProtobufSerializer<Aria_Session>(),
        interceptors: self.interceptors?.makeCreateSessionInterceptors() ?? [],
        wrapping: { try await self.createSession(request: $0, context: $1) }
      )

    case "GetSession":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Aria_GetSessionRequest>(),
        responseSerializer: ProtobufSerializer<Aria_Session>(),
        interceptors: self.interceptors?.makeGetSessionInterceptors() ?? [],
        wrapping: { try await self.getSession(request: $0, context: $1) }
      )

    case "ExecuteTurn":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Aria_ExecuteTurnRequest>(),
        responseSerializer: ProtobufSerializer<Aria_TurnOutput>(),
        interceptors: self.interceptors?.makeExecuteTurnInterceptors() ?? [],
        wrapping: { try await self.executeTurn(request: $0, responseStream: $1, context: $2) }
      )

    default:
      return nil
    }
  }
}

public protocol Aria_SessionServiceServerInterceptorFactoryProtocol: Sendable {

  /// - Returns: Interceptors to use when handling 'createSession'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeCreateSessionInterceptors() -> [ServerInterceptor<Aria_CreateSessionRequest, Aria_Session>]

  /// - Returns: Interceptors to use when handling 'getSession'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeGetSessionInterceptors() -> [ServerInterceptor<Aria_GetSessionRequest, Aria_Session>]

  /// - Returns: Interceptors to use when handling 'executeTurn'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeExecuteTurnInterceptors() -> [ServerInterceptor<Aria_ExecuteTurnRequest, Aria_TurnOutput>]
}

public enum Aria_SessionServiceServerMetadata {
  public static let serviceDescriptor = GRPCServiceDescriptor(
    name: "SessionService",
    fullName: "aria.SessionService",
    methods: [
      Aria_SessionServiceServerMetadata.Methods.createSession,
      Aria_SessionServiceServerMetadata.Methods.getSession,
      Aria_SessionServiceServerMetadata.Methods.executeTurn,
    ]
  )

  public enum Methods {
    public static let createSession = GRPCMethodDescriptor(
      name: "CreateSession",
      path: "/aria.SessionService/CreateSession",
      type: GRPCCallType.unary
    )

    public static let getSession = GRPCMethodDescriptor(
      name: "GetSession",
      path: "/aria.SessionService/GetSession",
      type: GRPCCallType.unary
    )

    public static let executeTurn = GRPCMethodDescriptor(
      name: "ExecuteTurn",
      path: "/aria.SessionService/ExecuteTurn",
      type: GRPCCallType.serverStreaming
    )
  }
}
/// Service for direct, low-level management of containers.
/// Wraps the underlying quilt daemon.
///
/// To build a server, implement a class that conforms to this protocol.
public protocol Aria_ContainerServiceProvider: CallHandlerProvider {
  var interceptors: Aria_ContainerServiceServerInterceptorFactoryProtocol? { get }

  func createContainer(request: Aria_CreateContainerRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Aria_Container>

  func startContainer(request: Aria_StartContainerRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Aria_StartContainerResponse>

  func stopContainer(request: Aria_StopContainerRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Aria_StopContainerResponse>

  func removeContainer(request: Aria_RemoveContainerRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Aria_RemoveContainerResponse>

  func getContainer(request: Aria_GetContainerRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Aria_Container>

  func listContainers(request: Aria_ListContainersRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Aria_ListContainersResponse>

  func streamContainerLogs(request: Aria_StreamContainerLogsRequest, context: StreamingResponseCallContext<Aria_ContainerLog>) -> EventLoopFuture<GRPCStatus>
}

extension Aria_ContainerServiceProvider {
  public var serviceName: Substring {
    return Aria_ContainerServiceServerMetadata.serviceDescriptor.fullName[...]
  }

  /// Determines, calls and returns the appropriate request handler, depending on the request's method.
  /// Returns nil for methods not handled by this service.
  public func handle(
    method name: Substring,
    context: CallHandlerContext
  ) -> GRPCServerHandlerProtocol? {
    switch name {
    case "CreateContainer":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Aria_CreateContainerRequest>(),
        responseSerializer: ProtobufSerializer<Aria_Container>(),
        interceptors: self.interceptors?.makeCreateContainerInterceptors() ?? [],
        userFunction: self.createContainer(request:context:)
      )

    case "StartContainer":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Aria_StartContainerRequest>(),
        responseSerializer: ProtobufSerializer<Aria_StartContainerResponse>(),
        interceptors: self.interceptors?.makeStartContainerInterceptors() ?? [],
        userFunction: self.startContainer(request:context:)
      )

    case "StopContainer":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Aria_StopContainerRequest>(),
        responseSerializer: ProtobufSerializer<Aria_StopContainerResponse>(),
        interceptors: self.interceptors?.makeStopContainerInterceptors() ?? [],
        userFunction: self.stopContainer(request:context:)
      )

    case "RemoveContainer":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Aria_RemoveContainerRequest>(),
        responseSerializer: ProtobufSerializer<Aria_RemoveContainerResponse>(),
        interceptors: self.interceptors?.makeRemoveContainerInterceptors() ?? [],
        userFunction: self.removeContainer(request:context:)
      )

    case "GetContainer":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Aria_GetContainerRequest>(),
        responseSerializer: ProtobufSerializer<Aria_Container>(),
        interceptors: self.interceptors?.makeGetContainerInterceptors() ?? [],
        userFunction: self.getContainer(request:context:)
      )

    case "ListContainers":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Aria_ListContainersRequest>(),
        responseSerializer: ProtobufSerializer<Aria_ListContainersResponse>(),
        interceptors: self.interceptors?.makeListContainersInterceptors() ?? [],
        userFunction: self.listContainers(request:context:)
      )

    case "StreamContainerLogs":
      return ServerStreamingServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Aria_StreamContainerLogsRequest>(),
        responseSerializer: ProtobufSerializer<Aria_ContainerLog>(),
        interceptors: self.interceptors?.makeStreamContainerLogsInterceptors() ?? [],
        userFunction: self.streamContainerLogs(request:context:)
      )

    default:
      return nil
    }
  }
}

/// Service for direct, low-level management of containers.
/// Wraps the underlying quilt daemon.
///
/// To implement a server, implement an object which conforms to this protocol.
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
public protocol Aria_ContainerServiceAsyncProvider: CallHandlerProvider, Sendable {
  static var serviceDescriptor: GRPCServiceDescriptor { get }
  var interceptors: Aria_ContainerServiceServerInterceptorFactoryProtocol? { get }

  func createContainer(
    request: Aria_CreateContainerRequest,
    context: GRPCAsyncServerCallContext
  ) async throws -> Aria_Container

  func startContainer(
    request: Aria_StartContainerRequest,
    context: GRPCAsyncServerCallContext
  ) async throws -> Aria_StartContainerResponse

  func stopContainer(
    request: Aria_StopContainerRequest,
    context: GRPCAsyncServerCallContext
  ) async throws -> Aria_StopContainerResponse

  func removeContainer(
    request: Aria_RemoveContainerRequest,
    context: GRPCAsyncServerCallContext
  ) async throws -> Aria_RemoveContainerResponse

  func getContainer(
    request: Aria_GetContainerRequest,
    context: GRPCAsyncServerCallContext
  ) async throws -> Aria_Container

  func listContainers(
    request: Aria_ListContainersRequest,
    context: GRPCAsyncServerCallContext
  ) async throws -> Aria_ListContainersResponse

  func streamContainerLogs(
    request: Aria_StreamContainerLogsRequest,
    responseStream: GRPCAsyncResponseStreamWriter<Aria_ContainerLog>,
    context: GRPCAsyncServerCallContext
  ) async throws
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension Aria_ContainerServiceAsyncProvider {
  public static var serviceDescriptor: GRPCServiceDescriptor {
    return Aria_ContainerServiceServerMetadata.serviceDescriptor
  }

  public var serviceName: Substring {
    return Aria_ContainerServiceServerMetadata.serviceDescriptor.fullName[...]
  }

  public var interceptors: Aria_ContainerServiceServerInterceptorFactoryProtocol? {
    return nil
  }

  public func handle(
    method name: Substring,
    context: CallHandlerContext
  ) -> GRPCServerHandlerProtocol? {
    switch name {
    case "CreateContainer":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Aria_CreateContainerRequest>(),
        responseSerializer: ProtobufSerializer<Aria_Container>(),
        interceptors: self.interceptors?.makeCreateContainerInterceptors() ?? [],
        wrapping: { try await self.createContainer(request: $0, context: $1) }
      )

    case "StartContainer":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Aria_StartContainerRequest>(),
        responseSerializer: ProtobufSerializer<Aria_StartContainerResponse>(),
        interceptors: self.interceptors?.makeStartContainerInterceptors() ?? [],
        wrapping: { try await self.startContainer(request: $0, context: $1) }
      )

    case "StopContainer":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Aria_StopContainerRequest>(),
        responseSerializer: ProtobufSerializer<Aria_StopContainerResponse>(),
        interceptors: self.interceptors?.makeStopContainerInterceptors() ?? [],
        wrapping: { try await self.stopContainer(request: $0, context: $1) }
      )

    case "RemoveContainer":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Aria_RemoveContainerRequest>(),
        responseSerializer: ProtobufSerializer<Aria_RemoveContainerResponse>(),
        interceptors: self.interceptors?.makeRemoveContainerInterceptors() ?? [],
        wrapping: { try await self.removeContainer(request: $0, context: $1) }
      )

    case "GetContainer":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Aria_GetContainerRequest>(),
        responseSerializer: ProtobufSerializer<Aria_Container>(),
        interceptors: self.interceptors?.makeGetContainerInterceptors() ?? [],
        wrapping: { try await self.getContainer(request: $0, context: $1) }
      )

    case "ListContainers":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Aria_ListContainersRequest>(),
        responseSerializer: ProtobufSerializer<Aria_ListContainersResponse>(),
        interceptors: self.interceptors?.makeListContainersInterceptors() ?? [],
        wrapping: { try await self.listContainers(request: $0, context: $1) }
      )

    case "StreamContainerLogs":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Aria_StreamContainerLogsRequest>(),
        responseSerializer: ProtobufSerializer<Aria_ContainerLog>(),
        interceptors: self.interceptors?.makeStreamContainerLogsInterceptors() ?? [],
        wrapping: { try await self.streamContainerLogs(request: $0, responseStream: $1, context: $2) }
      )

    default:
      return nil
    }
  }
}

public protocol Aria_ContainerServiceServerInterceptorFactoryProtocol: Sendable {

  /// - Returns: Interceptors to use when handling 'createContainer'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeCreateContainerInterceptors() -> [ServerInterceptor<Aria_CreateContainerRequest, Aria_Container>]

  /// - Returns: Interceptors to use when handling 'startContainer'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeStartContainerInterceptors() -> [ServerInterceptor<Aria_StartContainerRequest, Aria_StartContainerResponse>]

  /// - Returns: Interceptors to use when handling 'stopContainer'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeStopContainerInterceptors() -> [ServerInterceptor<Aria_StopContainerRequest, Aria_StopContainerResponse>]

  /// - Returns: Interceptors to use when handling 'removeContainer'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeRemoveContainerInterceptors() -> [ServerInterceptor<Aria_RemoveContainerRequest, Aria_RemoveContainerResponse>]

  /// - Returns: Interceptors to use when handling 'getContainer'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeGetContainerInterceptors() -> [ServerInterceptor<Aria_GetContainerRequest, Aria_Container>]

  /// - Returns: Interceptors to use when handling 'listContainers'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeListContainersInterceptors() -> [ServerInterceptor<Aria_ListContainersRequest, Aria_ListContainersResponse>]

  /// - Returns: Interceptors to use when handling 'streamContainerLogs'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeStreamContainerLogsInterceptors() -> [ServerInterceptor<Aria_StreamContainerLogsRequest, Aria_ContainerLog>]
}

public enum Aria_ContainerServiceServerMetadata {
  public static let serviceDescriptor = GRPCServiceDescriptor(
    name: "ContainerService",
    fullName: "aria.ContainerService",
    methods: [
      Aria_ContainerServiceServerMetadata.Methods.createContainer,
      Aria_ContainerServiceServerMetadata.Methods.startContainer,
      Aria_ContainerServiceServerMetadata.Methods.stopContainer,
      Aria_ContainerServiceServerMetadata.Methods.removeContainer,
      Aria_ContainerServiceServerMetadata.Methods.getContainer,
      Aria_ContainerServiceServerMetadata.Methods.listContainers,
      Aria_ContainerServiceServerMetadata.Methods.streamContainerLogs,
    ]
  )

  public enum Methods {
    public static let createContainer = GRPCMethodDescriptor(
      name: "CreateContainer",
      path: "/aria.ContainerService/CreateContainer",
      type: GRPCCallType.unary
    )

    public static let startContainer = GRPCMethodDescriptor(
      name: "StartContainer",
      path: "/aria.ContainerService/StartContainer",
      type: GRPCCallType.unary
    )

    public static let stopContainer = GRPCMethodDescriptor(
      name: "StopContainer",
      path: "/aria.ContainerService/StopContainer",
      type: GRPCCallType.unary
    )

    public static let removeContainer = GRPCMethodDescriptor(
      name: "RemoveContainer",
      path: "/aria.ContainerService/RemoveContainer",
      type: GRPCCallType.unary
    )

    public static let getContainer = GRPCMethodDescriptor(
      name: "GetContainer",
      path: "/aria.ContainerService/GetContainer",
      type: GRPCCallType.unary
    )

    public static let listContainers = GRPCMethodDescriptor(
      name: "ListContainers",
      path: "/aria.ContainerService/ListContainers",
      type: GRPCCallType.unary
    )

    public static let streamContainerLogs = GRPCMethodDescriptor(
      name: "StreamContainerLogs",
      path: "/aria.ContainerService/StreamContainerLogs",
      type: GRPCCallType.serverStreaming
    )
  }
}
/// Service for streaming real-time events from the runtime to the client.
///
/// To build a server, implement a class that conforms to this protocol.
public protocol Aria_NotificationServiceProvider: CallHandlerProvider {
  var interceptors: Aria_NotificationServiceServerInterceptorFactoryProtocol? { get }

  /// Establishes a persistent stream for the client to receive notifications.
  func streamNotifications(request: Aria_StreamNotificationsRequest, context: StreamingResponseCallContext<Aria_Notification>) -> EventLoopFuture<GRPCStatus>
}

extension Aria_NotificationServiceProvider {
  public var serviceName: Substring {
    return Aria_NotificationServiceServerMetadata.serviceDescriptor.fullName[...]
  }

  /// Determines, calls and returns the appropriate request handler, depending on the request's method.
  /// Returns nil for methods not handled by this service.
  public func handle(
    method name: Substring,
    context: CallHandlerContext
  ) -> GRPCServerHandlerProtocol? {
    switch name {
    case "StreamNotifications":
      return ServerStreamingServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Aria_StreamNotificationsRequest>(),
        responseSerializer: ProtobufSerializer<Aria_Notification>(),
        interceptors: self.interceptors?.makeStreamNotificationsInterceptors() ?? [],
        userFunction: self.streamNotifications(request:context:)
      )

    default:
      return nil
    }
  }
}

/// Service for streaming real-time events from the runtime to the client.
///
/// To implement a server, implement an object which conforms to this protocol.
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
public protocol Aria_NotificationServiceAsyncProvider: CallHandlerProvider, Sendable {
  static var serviceDescriptor: GRPCServiceDescriptor { get }
  var interceptors: Aria_NotificationServiceServerInterceptorFactoryProtocol? { get }

  /// Establishes a persistent stream for the client to receive notifications.
  func streamNotifications(
    request: Aria_StreamNotificationsRequest,
    responseStream: GRPCAsyncResponseStreamWriter<Aria_Notification>,
    context: GRPCAsyncServerCallContext
  ) async throws
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension Aria_NotificationServiceAsyncProvider {
  public static var serviceDescriptor: GRPCServiceDescriptor {
    return Aria_NotificationServiceServerMetadata.serviceDescriptor
  }

  public var serviceName: Substring {
    return Aria_NotificationServiceServerMetadata.serviceDescriptor.fullName[...]
  }

  public var interceptors: Aria_NotificationServiceServerInterceptorFactoryProtocol? {
    return nil
  }

  public func handle(
    method name: Substring,
    context: CallHandlerContext
  ) -> GRPCServerHandlerProtocol? {
    switch name {
    case "StreamNotifications":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Aria_StreamNotificationsRequest>(),
        responseSerializer: ProtobufSerializer<Aria_Notification>(),
        interceptors: self.interceptors?.makeStreamNotificationsInterceptors() ?? [],
        wrapping: { try await self.streamNotifications(request: $0, responseStream: $1, context: $2) }
      )

    default:
      return nil
    }
  }
}

public protocol Aria_NotificationServiceServerInterceptorFactoryProtocol: Sendable {

  /// - Returns: Interceptors to use when handling 'streamNotifications'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeStreamNotificationsInterceptors() -> [ServerInterceptor<Aria_StreamNotificationsRequest, Aria_Notification>]
}

public enum Aria_NotificationServiceServerMetadata {
  public static let serviceDescriptor = GRPCServiceDescriptor(
    name: "NotificationService",
    fullName: "aria.NotificationService",
    methods: [
      Aria_NotificationServiceServerMetadata.Methods.streamNotifications,
    ]
  )

  public enum Methods {
    public static let streamNotifications = GRPCMethodDescriptor(
      name: "StreamNotifications",
      path: "/aria.NotificationService/StreamNotifications",
      type: GRPCCallType.serverStreaming
    )
  }
}
/// Service for managing and deploying .aria bundles.
///
/// To build a server, implement a class that conforms to this protocol.
public protocol Aria_BundleServiceProvider: CallHandlerProvider {
  var interceptors: Aria_BundleServiceServerInterceptorFactoryProtocol? { get }

  /// Uploads a bundle to the runtime via a client-side stream.
  /// The first message in the stream must be a `Metadata` message.
  /// All subsequent messages must be `Chunk` messages.
  func uploadBundle(context: UnaryResponseCallContext<Aria_UploadBundleResponse>) -> EventLoopFuture<(StreamEvent<Aria_UploadBundleRequest>) -> Void>
}

extension Aria_BundleServiceProvider {
  public var serviceName: Substring {
    return Aria_BundleServiceServerMetadata.serviceDescriptor.fullName[...]
  }

  /// Determines, calls and returns the appropriate request handler, depending on the request's method.
  /// Returns nil for methods not handled by this service.
  public func handle(
    method name: Substring,
    context: CallHandlerContext
  ) -> GRPCServerHandlerProtocol? {
    switch name {
    case "UploadBundle":
      return ClientStreamingServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Aria_UploadBundleRequest>(),
        responseSerializer: ProtobufSerializer<Aria_UploadBundleResponse>(),
        interceptors: self.interceptors?.makeUploadBundleInterceptors() ?? [],
        observerFactory: self.uploadBundle(context:)
      )

    default:
      return nil
    }
  }
}

/// Service for managing and deploying .aria bundles.
///
/// To implement a server, implement an object which conforms to this protocol.
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
public protocol Aria_BundleServiceAsyncProvider: CallHandlerProvider, Sendable {
  static var serviceDescriptor: GRPCServiceDescriptor { get }
  var interceptors: Aria_BundleServiceServerInterceptorFactoryProtocol? { get }

  /// Uploads a bundle to the runtime via a client-side stream.
  /// The first message in the stream must be a `Metadata` message.
  /// All subsequent messages must be `Chunk` messages.
  func uploadBundle(
    requestStream: GRPCAsyncRequestStream<Aria_UploadBundleRequest>,
    context: GRPCAsyncServerCallContext
  ) async throws -> Aria_UploadBundleResponse
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension Aria_BundleServiceAsyncProvider {
  public static var serviceDescriptor: GRPCServiceDescriptor {
    return Aria_BundleServiceServerMetadata.serviceDescriptor
  }

  public var serviceName: Substring {
    return Aria_BundleServiceServerMetadata.serviceDescriptor.fullName[...]
  }

  public var interceptors: Aria_BundleServiceServerInterceptorFactoryProtocol? {
    return nil
  }

  public func handle(
    method name: Substring,
    context: CallHandlerContext
  ) -> GRPCServerHandlerProtocol? {
    switch name {
    case "UploadBundle":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Aria_UploadBundleRequest>(),
        responseSerializer: ProtobufSerializer<Aria_UploadBundleResponse>(),
        interceptors: self.interceptors?.makeUploadBundleInterceptors() ?? [],
        wrapping: { try await self.uploadBundle(requestStream: $0, context: $1) }
      )

    default:
      return nil
    }
  }
}

public protocol Aria_BundleServiceServerInterceptorFactoryProtocol: Sendable {

  /// - Returns: Interceptors to use when handling 'uploadBundle'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeUploadBundleInterceptors() -> [ServerInterceptor<Aria_UploadBundleRequest, Aria_UploadBundleResponse>]
}

public enum Aria_BundleServiceServerMetadata {
  public static let serviceDescriptor = GRPCServiceDescriptor(
    name: "BundleService",
    fullName: "aria.BundleService",
    methods: [
      Aria_BundleServiceServerMetadata.Methods.uploadBundle,
    ]
  )

  public enum Methods {
    public static let uploadBundle = GRPCMethodDescriptor(
      name: "UploadBundle",
      path: "/aria.BundleService/UploadBundle",
      type: GRPCCallType.clientStreaming
    )
  }
}
